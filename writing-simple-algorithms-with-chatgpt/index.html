<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Joel Kitching"><link rel="shortcut icon" href=https://joelkitching.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://joelkitching.com/writing-simple-algorithms-with-chatgpt/><title>Writing simple algorithms with ChatGPT</title></head><body><header id=banner><h2><a href=https://joelkitching.com/>Joel Kitching</a></h2><nav><ul><li><a href=/ title>posts</a></li><li><a href=/about/ title>about</a></li><li><a href=https://twitter.com/joelkitching title>twitter</a></li><li><a href=https://github.com/jkitching title>github</a></li><li><a href=https://www.linkedin.com/in/joelkitching title>linkedin</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Writing simple algorithms with ChatGPT</h1><div><time>April 6, 2023</time></div></header><p>Lately, it&rsquo;s almost impossible to open up Hacker News without encountering an article extolling the virtues of LLM-assisted programming. I wanted to give it a try&mdash;but I decided to start with something small.</p><h1 id=problem-definition>Problem definition</h1><blockquote><p>Given an input array of 0&rsquo;s and 1&rsquo;s, produce an array where <code>output[i]</code> gives the consecutive count of <code>input[i]</code> up until position <code>i</code>.</p><p>For example:</p><ul><li><code>1110100001</code> → <code>1231112341</code></li><li><code>1010101</code> → <code>1111111</code></li><li><code>1111111</code> → <code>1234567</code></li></ul><p>Write a Python function called <code>consecutive_count</code>, which takes a list as its input, and outputs a list.</p></blockquote><h1 id=attempt-1>Attempt #1</h1><p>Fairly simple, right? I feed this text verbatim into ChatGPT, and it gives me this function:</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>output</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>output</span>
</span></span></code></pre></div></blockquote><p>Looks like it&rsquo;s counting consecutive 1&rsquo;s, resetting the count to 0 when it encounters a 0. This is confirmed by both ChatGPT&rsquo;s explanation, and the example it provides:</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>consecutive_count</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div></blockquote><h1 id=attempt-2>Attempt #2</h1><p>Perhaps my explanation is not clear enough for ChatGPT to interpret the correct meaning? I try a variation of the above prompt:</p><blockquote><p>Given an input array of arbitrary elements, produce an array where <code>output[i]</code> gives the consecutive count of <code>input[i]</code> up until position <code>i</code>, starting at 1.</p><p>For example:</p><ul><li>1110100001 → 1231112341</li><li>1010101 → 1111111</li><li>1111111 → 1234567</li></ul><p>Write a Python function called <code>consecutive_count</code>, which takes a list as its input, and outputs a list.</p></blockquote><p>This time, ChatGPT seems to think that it should output the <em>overall</em> count of each encountered item, without resetting the count after a contiguous group ends:</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>input_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>output_list</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>element</span> <span class=ow>in</span> <span class=n>input_list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>element</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span><span class=p>[</span><span class=n>element</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=p>[</span><span class=n>element</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>output_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>count</span><span class=p>[</span><span class=n>element</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>output_list</span>
</span></span></code></pre></div></blockquote><p>But the example input/output it provides doesn&rsquo;t quite match this algorithm, leading me to believe that its internal representation of the problem is inconsistent.</p><h1 id=attempt-3>Attempt #3</h1><p>Perhaps we&rsquo;re overloading ChatGPT with too much information? Let&rsquo;s eliminate specific references to 0 and 1 in the prompt, avoid algebraic terms like <code>input[i]</code>, and do away with the examples.</p><blockquote><p>Given an input list of arbitrary items, produce a list of equivalent length, which provides the consecutive count of equivalent items up until that point in the input list. Counts start at 1.</p><p>Implement this with a Python function called <code>consecutive_count</code>.</p></blockquote><p>Success! This time, it spits out a working function:</p><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>lst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>counts</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>prev_item</span> <span class=o>=</span> <span class=n>lst</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>lst</span><span class=p>[</span><span class=mi>1</span><span class=p>:]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>item</span> <span class=o>==</span> <span class=n>prev_item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>counts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>counts</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>counts</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>prev_item</span> <span class=o>=</span> <span class=n>item</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>counts</span>
</span></span></code></pre></div></blockquote><p>It&rsquo;s a little on the verbose side though. Let&rsquo;s try:</p><blockquote><p>Rewrite <code>consecutive_count</code> to use less temporary variables.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>counts</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>lst</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>lst</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>lst</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>counts</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>counts</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>counts</span>
</span></span></code></pre></div></blockquote><p>That is much more concise! Thank you, ChatGPT.</p><h1 id=enter-functional-programming>Enter functional programming</h1><p>Let&rsquo;s see if ChatGPT is fluent in functional programming:</p><blockquote><p>Rewrite <code>consecutive_count</code> to use functional programming.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>input_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>groups</span> <span class=o>=</span> <span class=n>groupby</span><span class=p>(</span><span class=n>input_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=nb>sum</span><span class=p>(</span><span class=mi>1</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>group</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>groups</span><span class=p>]</span>
</span></span></code></pre></div></blockquote><p>Well&mldr; that&rsquo;s not quite right. This function outputs the size of each contiguous group of equivalent items.</p><blockquote><p>That&rsquo;s not quite right! This function just outputs the sizes of each group, instead of counting up from 1 within each group.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>input_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>output_list</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>group</span> <span class=ow>in</span> <span class=n>groupby</span><span class=p>(</span><span class=n>input_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>group_size</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>group</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>output_list</span> <span class=o>+=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>group_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>output_list</span>
</span></span></code></pre></div></blockquote><p>That&rsquo;s better! But a bit on the verbose side.</p><blockquote><p>That looks good, but avoid using a <code>for</code> loop.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>j</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>g</span> <span class=ow>in</span> <span class=n>groupby</span><span class=p>(</span><span class=n>lst</span><span class=p>)</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>g</span><span class=p>))</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span></code></pre></div></blockquote><p>Not bad at all. However, some people (such as myself) find double list comprehensions somewhat difficult to read.</p><blockquote><p>That looks fantastic. Could we break the list comprehension into two steps?</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span><span class=p>,</span> <span class=n>chain</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>input_list</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>groups</span> <span class=o>=</span> <span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>g</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>g</span> <span class=ow>in</span> <span class=n>groupby</span><span class=p>(</span><span class=n>input_list</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>list</span><span class=p>(</span><span class=n>chain</span><span class=o>.</span><span class=n>from_iterable</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>g</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=k>for</span> <span class=n>g</span> <span class=ow>in</span> <span class=n>groups</span><span class=p>))</span>
</span></span></code></pre></div></blockquote><p>Wow! I actually had to look up <a href=https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable><code>chain.from_iterable</code></a> to see what was going on here. It&rsquo;s basically a generator-aware flatten function, which is just what we need.</p><h1 id=alternative-solution>Alternative solution</h1><p>Originally, I had a solution in mind which uses <code>reduce</code>. Let&rsquo;s see if we can guide ChatGPT to use this method:</p><blockquote><p>Please rewrite <code>consecutive_count</code> to make use of <code>reduce</code>.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>itertools</span> <span class=kn>import</span> <span class=n>groupby</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>groups</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>list</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]),</span> <span class=n>groupby</span><span class=p>(</span><span class=n>lst</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>counts</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>),</span> <span class=n>groups</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>reduce</span><span class=p>(</span><span class=k>lambda</span> <span class=n>acc</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=n>acc</span> <span class=o>+</span> <span class=nb>list</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=n>counts</span><span class=p>,</span> <span class=p>[])</span>
</span></span></code></pre></div></blockquote><p>This is not quite what I was looking for&mldr; it basically uses <code>reduce</code> as a glorified <code>map</code>. Let&rsquo;s try again.</p><blockquote><p>Please rewrite <code>consecutive_count</code> to make use of the <code>reduce</code> function. There should be no need to use <code>groupby</code> or <code>map</code>.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>accumulate_counts</span><span class=p>(</span><span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>acc</span> <span class=ow>and</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>count</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>count</span> <span class=ow>in</span> <span class=n>reduce</span><span class=p>(</span><span class=n>accumulate_counts</span><span class=p>,</span> <span class=n>lst</span><span class=p>,</span> <span class=p>[])]</span>
</span></span></code></pre></div></blockquote><p>This is actually really close to a working implementation. For each item encountered, a tuple is added to the accumulator output list. The first element of the tuple is the <em>current item</em> (the value at <code>lst[i]</code>), and the second element is the <em>count</em> (the output of our algorithm). Finally, the first element of each tuple is stripped off in a final list comprehension.</p><p>But for some reason, ChatGPT is <em>modifying</em> the last element of the accumulator output list in the <code>if</code> clause of the conditional.</p><blockquote><p>That looks really close. But the <code>if</code> clause of the conditional should be <em>appending</em> to <code>acc</code> instead of modifying its last value.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>accumulate_counts</span><span class=p>(</span><span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>acc</span> <span class=ow>and</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>count</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>count</span> <span class=ow>in</span> <span class=n>reduce</span><span class=p>(</span><span class=n>accumulate_counts</span><span class=p>,</span> <span class=n>lst</span><span class=p>,</span> <span class=p>[])]</span>
</span></span></code></pre></div></blockquote><p>Wow! We did it! Now let&rsquo;s iterate for style:</p><blockquote><p>Great! Can you factor out the <code>append</code> call? The second element of the tuple passed to <code>append</code> should be a conditional expression. Assume that <code>acc</code> has at least one element in it, so there is no need to check for <code>acc</code> in the conditional.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>accumulate_counts</span><span class=p>(</span><span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=p>(</span><span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=k>if</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span> <span class=k>else</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=n>count</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>count</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>count</span> <span class=ow>in</span> <span class=n>reduce</span><span class=p>(</span><span class=n>accumulate_counts</span><span class=p>,</span> <span class=n>lst</span><span class=p>,</span> <span class=p>[(</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>)])][</span><span class=mi>1</span><span class=p>:]</span>
</span></span></code></pre></div></blockquote><p>Almost there!</p><blockquote><p>Awesome. Let&rsquo;s turn <code>accumulate_counts</code> into a lambda and assign it to a variable. Call it <code>acc_counts</code> instead.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>acc_counts</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=p>(</span><span class=n>acc</span> <span class=o>+</span> <span class=p>[(</span><span class=n>item</span><span class=p>,</span> <span class=p>(</span><span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=k>if</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span> <span class=k>else</span> <span class=mi>1</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>count</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>count</span> <span class=ow>in</span> <span class=n>reduce</span><span class=p>(</span><span class=n>acc_counts</span><span class=p>,</span> <span class=n>lst</span><span class=p>,</span> <span class=p>[(</span><span class=kc>None</span><span class=p>,</span> <span class=kc>None</span><span class=p>)])][</span><span class=mi>1</span><span class=p>:]</span>
</span></span></code></pre></div></blockquote><p>And we&rsquo;re done.</p><h1 id=extra-points>Extra points</h1><p>Let&rsquo;s explore how nimble ChatGPT is on its feet.</p><blockquote><p>I&rsquo;d like to modify this <code>reduce</code> implementation to store <em>only one</em> instance of the current item. The accumulator data format should look like: <code>(current_item, [output_list])</code>.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>acc_counts</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>acc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>([</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>item</span> <span class=o>!=</span> <span class=n>acc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>else</span> <span class=p>[</span><span class=n>acc</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>acc_counts</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>lst</span> <span class=k>else</span> <span class=p>[]</span>
</span></span></code></pre></div></blockquote><p>Subscripting a lambda&mldr; that&rsquo;s&mldr; cute? Two more prompts to get ChatGPT back on track:</p><blockquote><p>That looks close, but you forgot to run <code>reduce</code>!</p></blockquote><blockquote><p>There&rsquo;s no need for the conditional on the last line checking <code>lst</code>.</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>reduce</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consecutive_count</span><span class=p>(</span><span class=n>lst</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>acc_counts</span> <span class=o>=</span> <span class=k>lambda</span> <span class=n>acc</span><span class=p>,</span> <span class=n>item</span><span class=p>:</span> <span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>acc</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>([</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>item</span> <span class=o>!=</span> <span class=n>acc</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>else</span> <span class=p>[</span><span class=n>acc</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>reduce</span><span class=p>(</span><span class=n>acc_counts</span><span class=p>,</span> <span class=n>lst</span><span class=p>,</span> <span class=p>(</span><span class=kc>None</span><span class=p>,</span> <span class=p>[]))[</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div></blockquote><p>And we did it! ChatGPT, you are certainly impressive.</p><h1 id=conclusion>Conclusion</h1><p>I have a confession to make: this process was nowhere near as simple as this blog post makes it sound.</p><ul><li>Initially, I went down a huge rabbit hole of using the initial definition of the problem (specifying 0&rsquo;s and 1&rsquo;s). I asked for an implementation, copied errors or incorrect output from Python back into the ChatGPT prompt, and repeated this process about 10 times. ChatGPT didn&rsquo;t seem to grasp the concept, providing many variations, none of which were correct.</li><li>Then, I tried to &ldquo;teach&rdquo; ChatGPT how to perform the algorithm step-by-step. But once we reached the conditional inside the accumulator function (we were working on the <code>reduce</code> implementation), ChatGPT was <strong>convinced</strong> that the last value of the accumulator list needed to be <em>replaced</em> instead of appending a new tuple. <strong>NOTHING</strong> I said could convince it otherwise.<blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=n>acc</span> <span class=ow>and</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>item</span><span class=p>,</span> <span class=n>acc</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>acc</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></div></blockquote></li><li>At this point, I began to doubt whether ChatGPT even understood the problem in the first place. I prompted it with the problem definition, provided several input/output examples, and asked it to generate some examples on its own. Many of the examples that ChatGPT generated were incorrect. I kept fixing its examples and prompting them back, hoping that its internal representation would eventually align. But this approach was definitely a dead end! In fact, sometimes I would fix an example, and ChatGPT would make slight modifications when acknowledging and repeating the example back to me.</li><li>Finally, I tried the approach that ultimately worked for this blog post: rewriting the problem definition to be more general, without specifying the input constraints of using only 0&rsquo;s and 1&rsquo;s. I suspect that this algorithm may exist in ChatGPT&rsquo;s training data, but perhaps without the constraint of using only 0&rsquo;s and 1&rsquo;s. Maybe once that constraint was removed, ChatGPT had an easier time mapping to the correct answer internally.</li></ul><p>So how does it feel to write code with your own personal assistant? Initially, it felt maddening, like talking to a very smart child who could implement complex algorithms, but refused to make fixes to said algorithm when asked.</p><p>Once I got past the initial difficulty of properly communicating the problem, and started to get the hang of prompting, it was actually quite a rewarding experience. I could be as vague or specific as I wanted, and ChatGPT was generally very accommodating. Of course, there were still certain cases where I had to revise my prompt. For example, when asking ChatGPT to write a <strong>slightly</strong> more concise version, it might go from eight lines directly to a one-liner. Prompting is still somewhat of an art.</p><p>It also strangely felt like ChatGPT and I were working as a team, which is why I keep falling back to the &ldquo;we&rdquo; pronoun in this blog post. I found myself politely asking ChatGPT for help, and praising it (him? her? them?) for good answers.</p><p>I initially set out on this adventure specifically with the <code>reduce</code> solution in mind. But I actually prefer the solution that ChatGPT invented, which uses <code>groupby</code> and <code>from_iterable</code>. The fact that ChatGPT can understand the &ldquo;gist&rdquo; of what I&rsquo;m trying to accomplish, and effortlessly translate between different implementations, is infinitely cool. And also provides for learning opportunities!</p><p>I don&rsquo;t have access to GPT-4 yet, but I would be very curious to see how it performs with the initial problem definitions given in <a href=#attempt-1>Attempt #1</a> and <a href=#attempt-2>Attempt #2</a>. I invite any happy readers to paste those prompts into GPT-4 and let me know what happens!</p></article></main><footer id=footer>Copyright © 2022 Joel Isaac Stewart Davies-Kitching</footer></body></html>