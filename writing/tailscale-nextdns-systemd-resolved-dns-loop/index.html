<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Joel Kitching"><link rel="shortcut icon" href=https://joelkitching.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://joelkitching.com/writing/tailscale-nextdns-systemd-resolved-dns-loop/><title>Fixing Tailscale + NextDNS + systemd-resolved DNS loops on Linux</title></head><body><header id=banner><h2><a href=https://joelkitching.com/>Joel Kitching</a></h2><nav><ul><li><a href=/ title>writing</a></li><li><a href=/about/ title>about</a></li><li><a href=https://github.com/jkitching title>github</a></li><li><a href=https://www.linkedin.com/in/joelkitching title>linkedin</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Fixing Tailscale + NextDNS + systemd-resolved DNS loops on Linux</h1><div><time>January 12, 2026</time></div></header><p><em>Disclaimer: This post was written by Claude with my direction! We&rsquo;re all in the midst of recalibrating our ethical compass when it comes to programming and writing with LLMs. Since this post is intended as a reference for future me, it felt okay that I was simply a collaborator and editor.</em></p><h2 id=tailscale-goes-wild>Tailscale goes wild</h2><p>Tailscale commands were hanging on my Arch Linux system. I wasn&rsquo;t using the stub-resolv.conf symlink at the time, so I tried switching to it as a potential fix. After connecting to WiFi, the journal filled with <code>dns udp query: request queue full</code> and DNS resolution stopped working entirely!</p><h2 id=the-problem>The problem</h2><p>When using Tailscale with NextDNS configured in the Tailscale admin console, combined with systemd-resolved on Linux, you may encounter a DNS loop that causes complete DNS failure. The symptom is tailscaled spamming the journal with:</p><pre tabindex=0><code>dns udp query: request queue full
dns tcp query: request queue full
[RATELIMIT] format(&#34;dns udp query: %v&#34;) (106 dropped)
</code></pre><p>The system can ping IP addresses but cannot resolve any hostnames. Killing tailscaled restores DNS.</p><h2 id=why-it-happens>Why it happens</h2><p>The root cause is that Tailscale&rsquo;s internal DNS forwarder can end up with <code>100.100.100.100</code> (itself) in the upstream list, causing queries to loop infinitely until the queue is exhausted.</p><h3 id=the-loop-mechanism>The loop mechanism</h3><p>Once 100.100.100.100 is in the upstream list:</p><pre tabindex=0><code>Query arrives at 100.100.100.100 (Tailscale)
  → Not a MagicDNS query, forward upstream
  → Upstream includes 100.100.100.100
  → Query arrives at 100.100.100.100
  → Forward upstream...
  → ∞
</code></pre><p>This exponentially floods the queue until DNS stops working entirely.</p><h3 id=known-bugs-that-cause-this>Known bugs that cause this</h3><ul><li><a href=https://github.com/tailscale/tailscale/issues/7816>GitHub Issue #7816</a>&mdash;In &ldquo;direct&rdquo; mode, Tailscale&rsquo;s resolv.conf backup can become polluted with its own address</li><li><a href=https://github.com/tailscale/tailscale/issues/4842>GitHub Issue #4842</a>&mdash;After network disruptions (WiFi reconnect, router reboot), Tailscale&rsquo;s internal routing can misconfigure to point at itself</li><li><a href=https://github.com/tailscale/tailscale/issues/7655>GitHub Issue #7655</a>&mdash;Related DNS loop symptoms</li></ul><p>See also: <a href=https://tailscale.com/blog/sisyphean-dns-client-linux>Tailscale Blog: The Sisyphean Task of DNS Client Config on Linux</a></p><h2 id=the-solution>The solution</h2><p>Use NextDNS directly in systemd-resolved, bypass Tailscale&rsquo;s DNS override, and configure split DNS so MagicDNS still works for tailnet hostnames.</p><h3 id=step-1-configure-nextdns-in-systemd-resolved>Step 1: Configure NextDNS in systemd-resolved</h3><p>Edit <code>/etc/systemd/resolved.conf</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Resolve]</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.28.0#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.30.0#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>2a07:a8c0::#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>2a07:a8c1::#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNSOverTLS</span><span class=o>=</span><span class=s>yes</span>
</span></span></code></pre></div><p>Replace <code>YOUR-CONFIG-ID</code> with your NextDNS configuration ID (found at <a href=https://my.nextdns.io>https://my.nextdns.io</a>).</p><p>Restart resolved:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl restart systemd-resolved
</span></span></code></pre></div><h3 id=step-2-disable-tailscale-dns-override>Step 2: Disable Tailscale DNS override</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tailscale <span class=nb>set</span> --accept-dns<span class=o>=</span><span class=nb>false</span>
</span></span></code></pre></div><p>This prevents Tailscale from taking over global DNS routing.</p><h3 id=step-3-configure-split-dns-for-magicdns>Step 3: Configure split DNS for MagicDNS</h3><p>So you can still resolve tailnet hostnames like <code>mydevice.tail123abc.ts.net</code>, configure the <code>tailscale0</code> interface to route <code>.ts.net</code> queries to Tailscale&rsquo;s DNS. Create a NetworkManager dispatcher script to apply this on every connect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tee /etc/NetworkManager/dispatcher.d/50-tailscale-dns <span class=s>&lt;&lt; &#39;EOF&#39;
</span></span></span><span class=line><span class=cl><span class=s>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=s>if [ &#34;$1&#34; = &#34;tailscale0&#34; ] &amp;&amp; [ &#34;$2&#34; = &#34;up&#34; ]; then
</span></span></span><span class=line><span class=cl><span class=s>    resolvectl dns tailscale0 100.100.100.100
</span></span></span><span class=line><span class=cl><span class=s>    resolvectl domain tailscale0 tail123abc.ts.net &#39;~tail123abc.ts.net&#39;
</span></span></span><span class=line><span class=cl><span class=s>fi
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sudo chmod +x /etc/NetworkManager/dispatcher.d/50-tailscale-dns
</span></span></code></pre></div><p>Replace <code>tail123abc.ts.net</code> with your actual tailnet domain. The <code>resolvectl domain</code> command sets two entries:</p><ul><li><strong>Search domain</strong> (<code>tail123abc.ts.net</code>): <code>ping samsung</code> expands to <code>ping samsung.tail123abc.ts.net</code></li><li><strong>Routing domain</strong> (<code>~tail123abc.ts.net</code>): the <code>~</code> prefix tells resolved to send queries ending in this domain to Tailscale</li></ul><h2 id=verification>Verification</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Check resolved config</span>
</span></span><span class=line><span class=cl>resolvectl status
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test NextDNS is working</span>
</span></span><span class=line><span class=cl><span class=c1># Visit https://test.nextdns.io in a browser</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test MagicDNS</span>
</span></span><span class=line><span class=cl>ping yourdevice.tail123abc.ts.net
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Or just the short name (search domain)</span>
</span></span><span class=line><span class=cl>ping yourdevice
</span></span></code></pre></div><h2 id=how-it-works>How it works</h2><p><code>/etc/resolv.conf</code> symlinks to systemd-resolved&rsquo;s stub, so all DNS queries go through resolved.</p><p><strong>Resolving <code>samsung</code>:</strong></p><p><code>samsung</code> → 127.0.0.53 (resolved) → append search domain → <code>samsung.tail123abc.ts.net</code> → routing domain match → 100.100.100.100 (Tailscale) → <code>100.x.y.z</code></p><p><strong>Resolving <code>samsung.tail123abc.ts.net</code>:</strong></p><p><code>samsung.tail123abc.ts.net</code> → 127.0.0.53 (resolved) → routing domain match → 100.100.100.100 (Tailscale) → <code>100.x.y.z</code></p><p><strong>Resolving <code>google.com</code>:</strong></p><p><code>google.com</code> → 127.0.0.53 (resolved) → no routing domain match → NextDNS via DoT → <code>142.250.x.x</code></p><p>Since <code>--accept-dns=false</code> prevents Tailscale from registering as the global handler, there&rsquo;s no path for 100.100.100.100 to end up in the upstream list&mdash;no loop.</p><h2 id=quick-reference>Quick reference</h2><table><thead><tr><th>Task</th><th>Command</th></tr></thead><tbody><tr><td>Check DNS status</td><td><code>resolvectl status</code></td></tr><tr><td>Test specific DNS server</td><td><code>dig @100.100.100.100 hostname</code></td></tr><tr><td>Temporarily change DNS</td><td><code>sudo resolvectl dns wlan0 8.8.8.8</code></td></tr><tr><td>Restart resolved</td><td><code>sudo systemctl restart systemd-resolved</code></td></tr><tr><td>Check tailscale DNS mode</td><td><code>tailscale debug prefs | grep -i dns</code></td></tr></tbody></table></article></main><footer id=footer>Copyright © 2022–2024 Joel Isaac Stewart Davies-Kitching</footer></body></html>