<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Joel Kitching"><link rel="shortcut icon" href=https://joelkitching.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://joelkitching.com/writing/restart-process-on-signal/><title>Restarting a process when a signal is received</title></head><body><header id=banner><h2><a href=https://joelkitching.com/>Joel Kitching</a></h2><nav><ul><li><a href=/ title>writing</a></li><li><a href=/about/ title>about</a></li><li><a href=https://github.com/jkitching title>github</a></li><li><a href=https://www.linkedin.com/in/joelkitching title>linkedin</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Restarting a process when a signal is received</h1><div><time>April 10, 2024</time></div></header><p>In larger applications, there is usually a CI/CD process, which tests, builds, and deploys new versions of the software.</p><p>Smaller applications typically start out with a simpler solution. In this case, I have an application running in a <code>screen</code> session, and I want a git <code>post-receive</code> hook to automatically <a href=https://joelkitching.com/writing/restart-process-on-signal/>update its code</a> and restart the process.</p><p><strong>Is it possible to write a one-line Bash wrapper which restarts the application when a specific signal is received?</strong> <a href=#using-exec-as-a-one-liner>TL;DR: Yes, it is possible.</a></p><p>This particular application is not thoroughly robust yet, so I do not want to restart it when the process exits on its own. Thus we have the following requirements:</p><ul><li>When the application exits, the wrapper quits with its exit code</li><li>When the wrapper is killed with SIGHUP, restart the application</li><li>When the wrapper is killed with any other signal, kill the application and exit</li></ul><p>Note that since the final goal is to write a compact one-liner, quotes will be omitted where possible.</p><h1 id=tail-recursive-approach>Tail recursive approach</h1><p>In this version, the <code>run</code> call in the <code>HUP</code> trap essentially takes over execution of the process. When it pops up to the previous trap, <code>exit</code> stops execution and propagates the exit code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl>run<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid; run; exit $?&#39;</span> HUP
</span></span><span class=line><span class=cl>run
</span></span></code></pre></div><p>Note that we need the extra <code>EXIT</code> trap to handle the case of killing the wrapper directly. Let&rsquo;s test sending various signals to the parent of <code>sleep</code> as well as the <code>sleep</code> process itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Send HUP and TERM signals to child process</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> -HUP <span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)</span>                      <span class=c1># exits</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> <span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)</span>                           <span class=c1># exits</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Send HUP and TERM signals to wrapper</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> -HUP <span class=k>$(</span>ps -o <span class=nv>ppid</span><span class=o>=</span> -p <span class=s2>&#34;</span><span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)</span><span class=s2>&#34;</span><span class=k>)</span>  <span class=c1># restarts</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> <span class=k>$(</span>ps -o <span class=nv>ppid</span><span class=o>=</span> -p <span class=s2>&#34;</span><span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)</span><span class=s2>&#34;</span><span class=k>)</span>       <span class=c1># exits</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Send INT signal to wrapper&#39;s process group</span>
</span></span><span class=line><span class=cl>&lt;Ctrl+C&gt; directly on the shell                         <span class=c1># exits</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> -INT -- -<span class=k>$(</span>ps -o <span class=nv>pgid</span><span class=o>=</span> -p <span class=k>$(</span>ps -o <span class=nv>ppid</span><span class=o>=</span> -p <span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)))</span>
</span></span></code></pre></div><p>Everything checks out. Next, we will stress-test this script, spamming it with <code>HUP</code> signals:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>wrapperpid</span><span class=o>=</span><span class=k>$(</span>ps -o <span class=nv>ppid</span><span class=o>=</span> -p <span class=s2>&#34;</span><span class=k>$(</span>pgrep -f <span class=s1>&#39;sleep inf&#39;</span><span class=k>)</span><span class=s2>&#34;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>count</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=k>while</span> true<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=k>$((</span>count++<span class=k>))</span>
</span></span><span class=line><span class=cl>    <span class=nb>kill</span> -HUP <span class=nv>$wrapperpid</span> <span class=o>||</span> <span class=nb>break</span>
</span></span><span class=line><span class=cl>    <span class=c1># Wait for wrapper to finish restarting child process</span>
</span></span><span class=line><span class=cl>    <span class=c1># Also try without this sleep call after fixing bugs listed below</span>
</span></span><span class=line><span class=cl>    sleep 0.01
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>It turns out this invariably causes the script to segfault, since it isn&rsquo;t true tail-optimized recursion&mdash;a stack overflow occurs somewhere around the 2800th restart on my machine.</p><p>Additionally, multiple <code>sleep</code> processes may end up running at the same time during execution, and there may be multiple <code>sleep</code> processes hanging around after the segfault occurs (or after killing the wrapper manually). There are two independent problems at play; can you find them? (Hmm, this seems like a great interview question&mldr;)</p><ol><li><p>The first occurs in the <code>run()</code> function, after starting a new <code>sleep</code> process, and before recording its PID: <code>sleep inf & pid=$!</code>. If the trap is triggered here, the PID will still point to the old <code>sleep</code> process and the new one will not be killed. The only way to solve this is to disable the trap during this critical section.</p></li><li><p>The second occurs within the <code>SIGHUP</code> trap itself: <code>kill $pid; run</code>. <code>kill</code> simply delivers a signal to the process, but does not wait for it to end. Since <code>run</code> goes ahead and starts a new <code>sleep</code> process, there may be multiple <code>sleep</code> calls running simultaneously. That said, given enough time, the extra (old) instances will eventually exit. Testing this is therefore slightly tricky. I replaced <code>sleep inf</code> with <code>( trap 'sleep 1' EXIT; while true; do true; done )</code> to confirm the problem. We can solve this issue by inserting a <code>wait $pid</code> in between <code>kill</code> and <code>run</code>.</p></li></ol><p>Here&rsquo;s a slightly more &ldquo;correct&rdquo; version of the script which takes these two issues into account. Unfortunately, there is nothing we can do about the stack overflow without a rewrite.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl>run<span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;&#39;</span> HUP
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;kill $pid; wait $pid; run; exit $?&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>run
</span></span></code></pre></div><h1 id=infinite-loop-approach>Infinite loop approach</h1><p>In this approach, an infinite while loop continually waits for the process to exit. When this happens, check whether or not the <code>sighup</code> flag was set in the <code>SIGHUP</code> trap. If it was, restart the application. Otherwise, exit the while loop.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>sighup</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;sighup=1; kill $pid&#39;</span> HUP
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$sighup</span><span class=s2>&#34;</span> -eq <span class=m>1</span> <span class=o>]</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nv>sighup</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>This iterative approach contains two particularly racy conditions. Can you find them? They are both quite similar to those encountered in the recursive approach.</p><ol><li><p>The first is after starting a new <code>sleep</code> process, and before recording its PID: <code>sleep inf & pid=$!</code>. This can be solved by disabling the trap during this critical section.</p></li><li><p>The second is slightly more subtle. When Bash receives a signal while running a built-in command like <code>wait</code>, it interrupts the command, runs the signal, and then continues to the command right <em>after</em> the one interrupted. In this case, if <code>wait $pid</code> is interrupted by <code>SIGHUP</code>, execution continues after the <code>wait $pid</code> command. So there is no guarantee the process has been killed yet. To fix this, we add a <code>wait $pid</code> at the end of the <code>SIGHUP</code> trap.</p></li></ol><p>Here&rsquo;s the updated version:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>sighup</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$sighup</span><span class=s2>&#34;</span> -eq <span class=m>1</span> <span class=o>]</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nv>sighup</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;&#39;</span> HUP
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;sighup=1; kill $pid; wait $pid&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>Unfortunately, it turns out this version also suffers from the segfault issue. Again, my understanding is that if the wrapper gets spammed with <code>HUP</code> signals, the traps will repeatedly get interrupted, and there will be a huge call stack of traps that eventually exceed the size of the available stack.</p><p>Perhaps we can try to fix this by making the trap just one statement, so that if it is interrupted, there will be nothing to run afterwards? Will Bash be smart enough to optimize these &ldquo;tail recursions&rdquo;?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>sighup</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$sighup</span><span class=s2>&#34;</span> -eq <span class=m>1</span> <span class=o>]</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nv>sighup</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;sighup=1&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>kill</span> <span class=nv>$pid</span> 2&gt;/dev/null
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>Note the careful order of <code>trap</code>, <code>kill</code>, <code>wait</code>.</p><p>This version results in Bash interspersing our application restarts with &ldquo;bad value&rdquo; warnings. I believe this is related to traps getting interrupted before running to completion, but I was unable to find a viable solution.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bash: warning: run_pending_traps: bad value in trap_list<span class=o>[</span>1<span class=o>]</span>: 0x1
</span></span></code></pre></div><p>But there is no segfault. Rejoice&mdash;this is our most stable version so far!</p><p>There is actually one more potential issue which exists in this solution and the recursive solution. If the wrapper process is killed in between starting the application and recording its PID (<code>sleep inf & pid=$!</code>), the child process will continue. I have not been able to reproduce this behaviour without inserting a pause in between these two commands, but I have also not proven that it cannot occur.</p><p>This is a useful and viable version to use, but let&rsquo;s also explore one more option.</p><h1 id=replacing-wrapper-using-exec>Replacing wrapper using exec</h1><p>This strategy replaces the running process with another by using <code>exec</code>. It unfortunately requires running the script as a file. <a href=#using-exec-as-a-one-liner>Or does it? Heh heh heh&mldr;</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl>sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null; wait $pid; exec &#34;$0&#34; &#34;$@&#34;&#39;</span> HUP
</span></span><span class=line><span class=cl><span class=nb>wait</span> <span class=nv>$pid</span>
</span></span></code></pre></div><p>The first iteration segfaults when spammed with <code>SIGHUP</code>. Presumably traps are building up in the call stack before they finish executing until the call stack runs out of memory.</p><p>Additionally, there is a problem where if the <code>HUP</code> trap hasn&rsquo;t been installed yet, the script will just exit when it receives <code>SIGHUP</code>. That is the default behaviour of <code>SIGHUP</code>&mdash;and it is actually quite hard to find a signal <em>without</em> any default behaviour. I ended up choosing <code>SIGURG</code>:</p><blockquote><p>The operating system sends this signal to a process using a network connection when &ldquo;urgent&rdquo; out of band data is sent to it.</p></blockquote><p>I am going to cut this journey short and say that I tried every possible permutation, and none of them worked. So I turned this model on its head: let the replacement process handle killing the application before spawning a new one:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;pkill -P $$&#39;</span> EXIT
</span></span><span class=line><span class=cl>pkill -P <span class=nv>$$</span>
</span></span><span class=line><span class=cl>pidwait -P <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;exec &#34;$0&#34; &#34;$@&#34;&#39;</span> URG
</span></span><span class=line><span class=cl><span class=nb>wait</span> <span class=nv>$!</span>
</span></span></code></pre></div><p>This is the version that worked the best, with one small caveat: if the wrapper is killed before the <code>EXIT</code> trap is installed, the application process will continue running.</p><p>If this is a concern for you, consider using the infinite loop approach instead. If you would like to play with quines, read onward!</p><h1 id=using-exec-as-a-one-liner>Using exec as a one-liner</h1><p>Ever heard of a <a href=https://en.wikipedia.org/wiki/Quine_(computing)>quine</a>? It&rsquo;s a program that, when run, will output its own source code.</p><p>Instead of a program outputting its source code, let&rsquo;s write a program which <em>runs</em> its own source code. Behold:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>(</span> <span class=nb>export</span> <span class=nv>program</span><span class=o>=</span><span class=s2>&#34;echo run myself; eval \&#34;\$program\&#34;&#34;</span><span class=p>;</span> <span class=nb>eval</span> <span class=s2>&#34;</span><span class=nv>$program</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span></code></pre></div><p>This <code>$program</code>, once invoked, will respawn itself indefinitely. Or rather, until it segfaults. Let&rsquo;s try again!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>(</span> <span class=nb>export</span> <span class=nv>program</span><span class=o>=</span><span class=s2>&#34;echo run myself; exec bash -c \&#34;\$program\&#34;&#34;</span><span class=p>;</span> <span class=nb>eval</span> <span class=s2>&#34;</span><span class=nv>$program</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span></code></pre></div><p>Behold! It really does respawn indefinitely. Pretty neat, huh? Now we shove everything from our script above into the string, and we get:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>(</span> <span class=nb>export</span> <span class=nv>wrapper</span><span class=o>=</span><span class=s2>&#34;trap &#39;pkill -P \$\$&#39; EXIT;
</span></span></span><span class=line><span class=cl><span class=s2>  pkill -P \$\$; pidwait -P \$\$;
</span></span></span><span class=line><span class=cl><span class=s2>  echo restarting; sleep inf &amp;
</span></span></span><span class=line><span class=cl><span class=s2>  trap &#39;exec bash -c \&#34;\$wrapper\&#34;&#39; URG;
</span></span></span><span class=line><span class=cl><span class=s2>  wait \$!&#34;</span><span class=p>;</span> <span class=nb>exec</span> bash -c <span class=s2>&#34;</span><span class=nv>$wrapper</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span></code></pre></div><p>And that&rsquo;s all there is to it. =)</p><h1 id=identifying-the-wrapper>Identifying the wrapper</h1><p>Up until now, we have swept the problem of identifying the wrapper PID under the carpet, relying on a crude method of finding the parent PID of the <code>sleep inf</code> process.</p><p>There are two options here. The first is to save the wrapper&rsquo;s PID in a file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>(</span> <span class=nb>export</span> <span class=nv>wrapper</span><span class=o>=</span><span class=s2>&#34;trap &#39;pkill -P \$\$&#39; EXIT;
</span></span></span><span class=line><span class=cl><span class=s2>  pkill -P \$\$; pidwait -P \$\$;
</span></span></span><span class=line><span class=cl><span class=s2>  echo restarting; sleep inf &amp;
</span></span></span><span class=line><span class=cl><span class=s2>  trap &#39;exec bash -c \&#34;\$wrapper\&#34;&#39; URG;
</span></span></span><span class=line><span class=cl><span class=s2>  wait \$!&#34;</span><span class=p>;</span> <span class=nb>exec</span> bash -c <span class=s2>&#34;echo \$\$ &gt; wrapper.pid; </span><span class=nv>$wrapper</span><span class=s2>&#34;</span> <span class=o>)</span><span class=p>;</span> rm wrapper.pid
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Ask wrapper to restart the application:</span>
</span></span><span class=line><span class=cl><span class=nb>kill</span> -URG <span class=k>$(</span>cat wrapper.pid<span class=k>)</span>
</span></span></code></pre></div><p>The second is to assign a custom name to the process, which <code>exec</code> conveniently provides as the <code>-a</code> option:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>(</span> <span class=nb>export</span> <span class=nv>wrapper</span><span class=o>=</span><span class=s2>&#34;trap &#39;pkill -P \$\$&#39; EXIT;
</span></span></span><span class=line><span class=cl><span class=s2>  pkill -P \$\$; pidwait -P \$\$;
</span></span></span><span class=line><span class=cl><span class=s2>  echo restarting; sleep inf &amp;
</span></span></span><span class=line><span class=cl><span class=s2>  trap &#39;exec -a app_wrapper bash -c \&#34;\$wrapper\&#34;&#39; URG;
</span></span></span><span class=line><span class=cl><span class=s2>  wait \$!&#34;</span><span class=p>;</span> <span class=nb>exec</span> -a app_wrapper bash -c <span class=s2>&#34;</span><span class=nv>$wrapper</span><span class=s2>&#34;</span> <span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Ask wrapper to restart the application:</span>
</span></span><span class=line><span class=cl>pkill -f -URG app_wrapper
</span></span></code></pre></div><h1 id=caveat>Caveat</h1><p>If you have made it this far, you may have tried replacing <code>sleep inf</code> with a script or a function. It&rsquo;s remarkably hard to reliably kill all subprocesses when a parent process is killed. Consider this example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ <span class=o>{</span> sleep 100<span class=p>;</span> <span class=nb>echo</span> <span class=k>done</span><span class=p>;</span> <span class=o>}</span> <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>1<span class=o>]</span> <span class=m>688046</span>
</span></span><span class=line><span class=cl>$ <span class=nb>kill</span> <span class=m>688046</span>
</span></span><span class=line><span class=cl>$ ps ax <span class=p>|</span> grep <span class=s1>&#39;sleep 100&#39;</span>
</span></span><span class=line><span class=cl> <span class=m>688047</span> pts/10   S      0:00 sleep <span class=m>100</span>
</span></span></code></pre></div><p>To deal this complexity, consider simply killing the entire process group (like Ctrl+C does): <code>kill -- -process_group</code> (note the extra dash). If you would like to deal with this directly from the wrapper, <code>set -m</code> might be helpful. It temporarily enables Bash jobs control, which causes every child process to be created in its own separate process group.</p><p>For example, modifying the infinite loop version of the wrapper to handle creating process groups might look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>pid</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>sighup</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;kill $pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$sighup</span><span class=s2>&#34;</span> -eq <span class=m>1</span> <span class=o>]</span><span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nv>sighup</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    <span class=nb>set</span> -m
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nb>set</span> +m
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;sighup=1&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;&#39;</span> HUP
</span></span><span class=line><span class=cl>    <span class=nb>kill</span> -- -<span class=nv>$pid</span> 2&gt;/dev/null
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>Modifying the exec approach might look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;pgrep -P $$ | xargs -I {} kill -- &#39;</span>-<span class=o>{}</span><span class=s1>&#39; 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl>pgrep -P <span class=nv>$$</span> <span class=p>|</span> xargs -I <span class=o>{}</span> <span class=nb>kill</span> -- <span class=s1>&#39;-{}&#39;</span> 2&gt;/dev/null
</span></span><span class=line><span class=cl>pidwait -P <span class=nv>$$</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl><span class=nb>set</span> -m
</span></span><span class=line><span class=cl>sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl><span class=nb>set</span> +m
</span></span><span class=line><span class=cl><span class=nb>trap</span> <span class=s1>&#39;exec &#34;$0&#34; &#34;$@&#34;&#39;</span> URG
</span></span><span class=line><span class=cl><span class=nb>wait</span> <span class=nv>$!</span>
</span></span></code></pre></div><p>Or, keep that complexity in your application function/script:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>target<span class=o>()</span> <span class=o>(</span>
</span></span><span class=line><span class=cl>    <span class=nb>trap</span> <span class=s1>&#39;kill -- -$pid 2&gt;/dev/null&#39;</span> EXIT
</span></span><span class=line><span class=cl>    <span class=nb>set</span> -m
</span></span><span class=line><span class=cl>    sleep inf <span class=p>&amp;</span>
</span></span><span class=line><span class=cl>    <span class=nv>pid</span><span class=o>=</span><span class=nv>$!</span>
</span></span><span class=line><span class=cl>    <span class=nb>wait</span> <span class=nv>$pid</span>
</span></span><span class=line><span class=cl><span class=o>)</span>
</span></span></code></pre></div><h1 id=addendum>Addendum</h1><p>Remember that the above scripts will keep running until the application decides to exit on its own. If you would like a restart to also occur in that case, then I shall leave that modification as an exercise to the reader.</p><p>Finally, also consider just sending <code>SIGHUP</code> to your application, and having the wrapper restart it based on its exit code. This is vastly simpler since traps aren&rsquo;t needed:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=k>while</span> true<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> restarting
</span></span><span class=line><span class=cl>    sleep inf
</span></span><span class=line><span class=cl>    <span class=o>[</span> <span class=nv>$?</span> -eq <span class=m>129</span> <span class=o>]</span> <span class=o>||</span> <span class=nb>break</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span></code></pre></div><p>I had tons of fun learning about Bash traps while writing this article. For more information, check out:</p><ul><li><a href=https://mywiki.wooledge.org/SignalTrap>GreyCat&rsquo;s wiki&mdash;SignalTrap</a></li><li><a href=https://superuser.com/questions/1829830/behavior-of-sigint-with-bash>StackExchange&mdash;explanation of WCE (wait and cooperative exit)</a></li></ul></article></main><footer id=footer>Copyright © 2022–2024 Joel Isaac Stewart Davies-Kitching</footer></body></html>