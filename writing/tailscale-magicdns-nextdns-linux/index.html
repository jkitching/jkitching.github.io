<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Joel Kitching"><link rel="shortcut icon" href=https://joelkitching.com/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://joelkitching.com/writing/tailscale-magicdns-nextdns-linux/><title>Split DNS for Tailscale MagicDNS + NextDNS on Linux</title></head><body><header id=banner><h2><a href=https://joelkitching.com/>Joel Kitching</a></h2><nav><ul><li><a href=/ title>writing</a></li><li><a href=/about/ title>about</a></li><li><a href=https://github.com/jkitching title>github</a></li><li><a href=https://www.linkedin.com/in/joelkitching title>linkedin</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Split DNS for Tailscale MagicDNS + NextDNS on Linux</h1><div><time>January 12, 2026</time></div></header><p><em>Disclaimer: This post was written by Claude with my direction! We&rsquo;re all in the midst of recalibrating our ethical compass when it comes to programming and writing with LLMs. Since this post is intended as a reference for future me, it felt okay that I was simply a collaborator and editor.</em></p><p>This document describes a robust DNS configuration for Tailscale on Linux that provides:</p><ul><li>MagicDNS for tailnet hostname resolution</li><li>NextDNS for all other queries (with DNS-over-TLS encryption)</li><li>Resilience to network transitions (suspend/resume, wifi changes)</li><li>Protection against tailscaled&rsquo;s DNS queue exhaustion</li></ul><h2 id=the-problem-with---accept-dnstrue>The problem with <code>--accept-dns=true</code></h2><h3 id=how-it-works>How it works</h3><p>When <code>accept-dns=true</code> (the default), tailscaled configures systemd-resolved via D-Bus:</p><pre tabindex=0><code>SetLinkDNS(tailscale0, [100.100.100.100])
SetLinkDomains(tailscale0, [&#34;tail4a82f0.ts.net&#34;, &#34;~.&#34;])
SetLinkDefaultRoute(tailscale0, true)
</code></pre><p>The <code>~.</code> routing domain means <strong>all</strong> DNS queries flow through tailscaled:</p><pre tabindex=0><code>Application → 127.0.0.53 (resolved) → 100.100.100.100 (tailscaled) → NextDNS (DoH)
</code></pre><h3 id=the-queue-exhaustion-problem>The queue exhaustion problem</h3><p>tailscaled has an internal DNS query queue with a hard limit:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span><span class=w> </span><span class=nx>maxActiveQueries</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>256</span><span class=w>
</span></span></span></code></pre></div><p>When this queue is full, tailscaled immediately returns SERVFAIL:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>AddInt32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>.</span><span class=nx>activeQueriesAtomic</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>maxActiveQueries</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=nx>errFullQueue</span><span class=w>  </span><span class=c1>// instant SERVFAIL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=why-network-transitions-trigger-failure>Why network transitions trigger failure</h3><p>During suspend/resume or wifi reconnection:</p><ol><li><strong>Network goes down</strong> &mdash; tailscaled cannot reach upstream DNS (NextDNS via DoH)</li><li><strong>Queries accumulate</strong> &mdash; applications and system services make DNS requests</li><li><strong>DoH has slow failure</strong> &mdash; each query waits for TLS handshake timeout (~5-30 seconds)</li><li><strong>Queue fills</strong> &mdash; 256 in-flight queries waiting to timeout</li><li><strong>New queries rejected</strong> &mdash; instant SERVFAIL responses</li><li><strong>Network recovers</strong> &mdash; but queue is still full of timing-out queries</li><li><strong>Death spiral</strong> &mdash; resolved sees instant failures, retries aggressively</li></ol><h3 id=why-this-differs-from-normal-dns-server-failure>Why this differs from normal DNS server failure</h3><table><thead><tr><th>Scenario</th><th>Behavior</th><th>Result</th></tr></thead><tbody><tr><td>Remote DNS unreachable</td><td>Slow timeout (5+ sec)</td><td>Rate-limited retries, fallback works</td></tr><tr><td>tailscaled queue full</td><td>Instant SERVFAIL</td><td>Aggressive retries, no backoff</td></tr></tbody></table><p>With <code>~.</code> routing domain, resolved has no fallback&mdash;all queries must go to 100.100.100.100. The combination of instant failure + no fallback = complete DNS outage.</p><h3 id=evidence-from-logs>Evidence from logs</h3><pre tabindex=0><code>Jan 12 20:00:23 tailscaled: monitor: time jumped (probably wake from sleep)
Jan 12 20:00:27 tailscaled: [RATELIMIT] (48 dropped)
Jan 12 20:00:27 tailscaled: dns udp query: dial tcp [2a07:a8c0::d6:3326]:443: network is unreachable
Jan 12 20:00:32 systemd-resolved: Using degraded feature set TCP instead of UDP for DNS server 100.100.100.100
Jan 12 20:01:19 tailscaled: dns: tcp query: request queue full
</code></pre><h2 id=the-problem-with---accept-dnsfalse>The problem with <code>--accept-dns=false</code></h2><h3 id=expected-behavior>Expected behavior</h3><p>With <code>accept-dns=false</code>, tailscaled should not manage DNS at all, allowing manual split DNS configuration.</p><h3 id=actual-behavior>Actual behavior</h3><p>tailscaled still calls D-Bus methods to configure the tailscale0 interface, but with empty values:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// From resolved.go - setConfigOverDBus is called regardless of accept-dns setting</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>SetLinkDNS</span><span class=p>(</span><span class=nx>tailscale0</span><span class=p>,</span><span class=w> </span><span class=p>[])</span><span class=w>           </span><span class=c1>// clears DNS servers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>SetLinkDomains</span><span class=p>(</span><span class=nx>tailscale0</span><span class=p>,</span><span class=w> </span><span class=p>[])</span><span class=w>       </span><span class=c1>// clears routing domains</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>SetLinkDefaultRoute</span><span class=p>(</span><span class=nx>tailscale0</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=c1>// sets as default route</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>SetLinkLLMNR</span><span class=p>(</span><span class=nx>tailscale0</span><span class=p>,</span><span class=w> </span><span class=s>&#34;no&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>SetLinkMulticastDNS</span><span class=p>(</span><span class=nx>tailscale0</span><span class=p>,</span><span class=w> </span><span class=s>&#34;no&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nf>FlushCaches</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></div><p>This happens on network events like daemon startup, <code>LinkChange</code> events (network up/down, IP changes), and control plane config updates.</p><h3 id=impact-on-manual-configuration>Impact on manual configuration</h3><p>Any manual split DNS configuration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>resolvectl dns tailscale0 100.100.100.100
</span></span><span class=line><span class=cl>resolvectl domain tailscale0 tail4a82f0.ts.net
</span></span><span class=line><span class=cl>resolvectl default-route tailscale0 <span class=nb>false</span>
</span></span></code></pre></div><p>Gets overwritten on network events by tailscaled&rsquo;s empty config.</p><h3 id=evidence-from-logs-1>Evidence from logs</h3><pre tabindex=0><code>Jan 16 12:37:55 tailscale-dns.service sets DNS to 100.100.100.100
Jan 16 12:37:58 tailscaled resets: &#34;Bus client reset DNS server list&#34;
Jan 16 12:37:58 tailscaled resets: &#34;Bus client set default route setting: yes&#34;
</code></pre><p>This behavior is arguably intentional&mdash;tailscaled manages its own interface regardless of whether it&rsquo;s handling DNS for the whole system. But it means we need a workaround to maintain split DNS.</p><h2 id=understanding-systemd-resolved-dns-routing>Understanding systemd-resolved DNS routing</h2><h3 id=dns-server-priority>DNS server priority</h3><p>systemd-resolved uses this priority order:</p><ol><li><strong>Per-link with matching routing domain</strong> &mdash; e.g., tailscale0 with <code>tail4a82f0.ts.net</code></li><li><strong>Per-link with <code>DefaultRoute=yes</code></strong> &mdash; e.g., <code>wlp0s20f3</code> from DHCP</li><li><strong>Global DNS</strong> &mdash; from <code>/etc/systemd/resolved.conf</code></li></ol><h3 id=the--routing-domain>The <code>~.</code> routing domain</h3><p>A domain prefixed with <code>~</code> is a routing domain (not search domain):</p><ul><li><code>tail4a82f0.ts.net</code> → search domain, appended to single-label names</li><li><code>~tail4a82f0.ts.net</code> → routing domain, queries for <code>*.tail4a82f0.ts.net</code> go here</li><li><code>~.</code> → routing domain for root, captures <strong>all</strong> queries</li></ul><h3 id=why-global-dns-is-rarely-used>Why Global DNS is rarely used</h3><p>With typical wifi/ethernet connections:</p><pre tabindex=0><code>wlp0s20f3: DefaultRoute=yes, DNS=192.168.31.1 (from DHCP)
Global: DNS=45.90.28.0#nextdns (from resolved.conf)
</code></pre><p>The per-link DHCP DNS wins because <code>DefaultRoute=yes</code> has higher priority than Global. Without intervention, the <code>resolved.conf</code> NextDNS config is essentially unused.</p><h2 id=the-dnsovertlsyes-trick>The <code>DNSOverTLS=yes</code> trick</h2><h3 id=how-it-works-1>How it works</h3><p>In <code>/etc/systemd/resolved.conf</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Resolve]</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.28.0#d63326.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.30.0#d63326.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNSOverTLS</span><span class=o>=</span><span class=s>yes</span>
</span></span></code></pre></div><p><code>DNSOverTLS=yes</code> <strong>requires</strong> DNS-over-TLS for all queries.</p><h3 id=effect-on-dns-routing>Effect on DNS routing</h3><p>When resolved tries to use DHCP-provided DNS (e.g., <code>192.168.31.1</code>):</p><ol><li>Attempts DoT connection to <code>192.168.31.1:853</code></li><li>Home router doesn&rsquo;t support DoT → connection fails</li><li>Falls back to Global DNS (NextDNS)</li><li>NextDNS supports DoT → succeeds</li></ol><h3 id=result>Result</h3><p><code>DNSOverTLS=yes</code> acts as a filter that bypasses all non-DoT DNS servers:</p><ul><li>NextDNS (supports DoT) → <strong>used</strong></li><li>DHCP DNS (no DoT) → bypassed</li><li>Coffee shop DNS (no DoT) → bypassed</li></ul><p>This provides consistent NextDNS usage regardless of network, without configuring <code>ignore-auto-dns</code> on every connection.</p><h2 id=the-complete-solution>The complete solution</h2><h3 id=step-1-configure-nextdns-in-systemd-resolved>Step 1: Configure NextDNS in systemd-resolved</h3><p>Edit <code>/etc/systemd/resolved.conf</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Resolve]</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.28.0#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>45.90.30.0#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>2a07:a8c0::#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNS</span><span class=o>=</span><span class=s>2a07:a8c1::#YOUR-CONFIG-ID.dns.nextdns.io</span>
</span></span><span class=line><span class=cl><span class=na>DNSOverTLS</span><span class=o>=</span><span class=s>yes</span>
</span></span></code></pre></div><p>Replace <code>YOUR-CONFIG-ID</code> with your NextDNS configuration ID (found at <a href=https://my.nextdns.io>https://my.nextdns.io</a>).</p><p>Restart resolved:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl restart systemd-resolved
</span></span></code></pre></div><h3 id=step-2-prevent-networkmanager-from-managing-tailscale0>Step 2: Prevent NetworkManager from managing tailscale0</h3><p>Create <code>/etc/NetworkManager/conf.d/99-unmanaged-tailscale.conf</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[keyfile]</span>
</span></span><span class=line><span class=cl><span class=na>unmanaged-devices</span><span class=o>=</span><span class=s>interface-name:tailscale*</span>
</span></span></code></pre></div><h3 id=step-3-disable-tailscale-dns-override>Step 3: Disable Tailscale DNS override</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo tailscale <span class=nb>set</span> --accept-dns<span class=o>=</span><span class=nb>false</span>
</span></span></code></pre></div><p>This prevents tailscaled from setting the <code>~.</code> routing domain (which would route all queries through its queue).</p><h3 id=step-4-create-the-dns-fix-script>Step 4: Create the DNS fix script</h3><p>Create <code>/usr/local/bin/tailscale-dns-fix.sh</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl>sleep <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=k>if</span> ip link show tailscale0 <span class=p>&amp;</span>&gt;/dev/null<span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>    resolvectl dns tailscale0 100.100.100.100
</span></span><span class=line><span class=cl>    resolvectl domain tailscale0 YOUR-TAILNET.ts.net
</span></span><span class=line><span class=cl>    resolvectl default-route tailscale0 <span class=nb>false</span>
</span></span><span class=line><span class=cl>    logger -t tailscale-dns-fix <span class=s2>&#34;Applied MagicDNS config to tailscale0&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></div><p>Replace <code>YOUR-TAILNET.ts.net</code> with your actual tailnet domain.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo chmod +x /usr/local/bin/tailscale-dns-fix.sh
</span></span></code></pre></div><h3 id=step-5-create-the-watcher-service>Step 5: Create the watcher service</h3><p>Create <code>/etc/systemd/system/tailscale-dns-watch.service</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=k>[Unit]</span>
</span></span><span class=line><span class=cl><span class=na>Description</span><span class=o>=</span><span class=s>Watch tailscaled DNS changes and apply MagicDNS config</span>
</span></span><span class=line><span class=cl><span class=na>After</span><span class=o>=</span><span class=s>tailscaled.service</span>
</span></span><span class=line><span class=cl><span class=na>Requires</span><span class=o>=</span><span class=s>tailscaled.service</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Service]</span>
</span></span><span class=line><span class=cl><span class=na>Type</span><span class=o>=</span><span class=s>simple</span>
</span></span><span class=line><span class=cl><span class=na>ExecStart</span><span class=o>=</span><span class=s>/bin/bash -c &#39;journalctl -u tailscaled -f -n0 --grep=&#34;dns: Set:&#34; | while read line; do /usr/local/bin/tailscale-dns-fix.sh; done&#39;</span>
</span></span><span class=line><span class=cl><span class=na>Restart</span><span class=o>=</span><span class=s>always</span>
</span></span><span class=line><span class=cl><span class=na>RestartSec</span><span class=o>=</span><span class=s>5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>[Install]</span>
</span></span><span class=line><span class=cl><span class=na>WantedBy</span><span class=o>=</span><span class=s>multi-user.target</span>
</span></span></code></pre></div><p>Enable and start it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo systemctl daemon-reload
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> --now tailscale-dns-watch.service
</span></span></code></pre></div><p>This monitors tailscaled logs and re-applies split DNS whenever tailscaled resets it.</p><h2 id=how-it-works-2>How it works</h2><pre tabindex=0><code>                        Application
                            │
                            ▼
                    127.0.0.53 (resolved stub)
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
    *.YOUR-TAILNET.ts.net           Everything else
      (routing domain)
              │                           │
              ▼                           ▼
         tailscale0               wlp0s20f3 (DHCP DNS)
       100.100.100.100            192.168.31.1 - NO DoT
              │                           │
              ▼                           ▼ (DoT required, fails)
          MagicDNS                  Global DNS (NextDNS)
       (tailnet hosts)            45.90.28.0 - DoT works
</code></pre><table><thead><tr><th>Query</th><th>Route</th><th>DNS Server</th><th>Transport</th></tr></thead><tbody><tr><td><code>mydevice.YOUR-TAILNET.ts.net</code></td><td>tailscale0</td><td>100.100.100.100</td><td>UDP (local)</td></tr><tr><td><code>mydevice</code> (single-label)</td><td>tailscale0 (search domain)</td><td>100.100.100.100</td><td>UDP (local)</td></tr><tr><td><code>google.com</code></td><td>Global (DoT fallback)</td><td>NextDNS</td><td>DoT</td></tr><tr><td><code>any-website.com</code></td><td>Global (DoT fallback)</td><td>NextDNS</td><td>DoT</td></tr></tbody></table><h2 id=why-this-solution-is-robust>Why this solution is robust</h2><p><strong>Protection against queue exhaustion:</strong></p><ul><li>Regular DNS queries never touch tailscaled&mdash;they go directly to NextDNS via DoT</li><li>Only tailnet queries (<code>*.YOUR-TAILNET.ts.net</code>) go through 100.100.100.100</li><li>Network transitions don&rsquo;t cause queue buildup for regular DNS</li></ul><p><strong>Automatic recovery:</strong></p><ul><li><code>tailscale-dns-watch.service</code> detects when tailscaled resets DNS config</li><li>Re-applies split DNS within ~2 seconds</li><li>Works across tailscaled restarts and network changes</li></ul><p><strong>Consistent NextDNS usage:</strong></p><ul><li><code>DNSOverTLS=yes</code> bypasses any DHCP-provided DNS</li><li>Works on any network without per-network configuration</li><li>Encrypted DNS everywhere</li></ul><p><strong>MagicDNS functionality preserved:</strong></p><ul><li>Tailnet hostnames resolve via 100.100.100.100</li><li>Search domain allows <code>ping mydevice</code> instead of <code>ping mydevice.YOUR-TAILNET.ts.net</code></li><li>Split DNS means only tailnet queries have queue risk (minimal traffic)</li></ul><h2 id=verification>Verification</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Check resolved config</span>
</span></span><span class=line><span class=cl>resolvectl status
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check tailscale0 specifically</span>
</span></span><span class=line><span class=cl>resolvectl status tailscale0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test NextDNS is working</span>
</span></span><span class=line><span class=cl><span class=c1># Visit https://test.nextdns.io in a browser</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test MagicDNS</span>
</span></span><span class=line><span class=cl>ping mydevice.YOUR-TAILNET.ts.net
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Or just the short name (search domain)</span>
</span></span><span class=line><span class=cl>ping mydevice
</span></span></code></pre></div><h2 id=quick-reference>Quick reference</h2><table><thead><tr><th>Task</th><th>Command</th></tr></thead><tbody><tr><td>Check DNS status</td><td><code>resolvectl status</code></td></tr><tr><td>Check tailscale0 DNS config</td><td><code>resolvectl status tailscale0</code></td></tr><tr><td>Test specific DNS server</td><td><code>dig @100.100.100.100 hostname</code></td></tr><tr><td>Restart resolved</td><td><code>sudo systemctl restart systemd-resolved</code></td></tr><tr><td>Check watcher service</td><td><code>sudo systemctl status tailscale-dns-watch</code></td></tr><tr><td>Manually re-apply DNS fix</td><td><code>sudo /usr/local/bin/tailscale-dns-fix.sh</code></td></tr><tr><td>Check tailscale DNS mode</td><td><code>tailscale debug prefs | grep -i dns</code></td></tr></tbody></table><h2 id=known-limitations>Known limitations</h2><ol><li><strong>2-second window after tailscaled changes</strong> &mdash; brief period where MagicDNS may not work</li><li><strong>Relies on log monitoring</strong> &mdash; if journald is unavailable, watcher won&rsquo;t trigger</li><li><strong>Workaround for tailscaled behavior</strong> &mdash; ideally <code>accept-dns=false</code> would leave tailscale0&rsquo;s resolved config alone</li></ol><h2 id=see-also>See also</h2><ul><li><a href=https://tailscale.com/kb/1188/linux-dns>Tailscale: Linux DNS</a></li><li><a href=https://tailscale.com/blog/sisyphean-dns-client-linux>Tailscale Blog: The Sisyphean Task of DNS Client Config on Linux</a></li></ul></article></main><footer id=footer>Copyright © 2022–2024 Joel Isaac Stewart Davies-Kitching</footer></body></html>